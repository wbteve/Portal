<?php

/**
 * @file
 *
 * This module provides the RPX token handler and (sign-in) related logic for
 * Janrain Engage (formerly RPX).
 *
 * @see http://www.janrain.com/products/engage
 */

/*
 * Engage data update options.
 *
 * Then a linked account is added by user using the 3rd party identities tab in
 * the user profile, provider-sourced user profile data can optionally be
 * imported into the Drupal fields, using any of the below options.
 */
// Do not update the field (default).
define('RPX_UPDATE_NONE', 0);
// Only update the field if it is empty.
define('RPX_UPDATE_EMPTY', 1);
// Always update (overwriting the existing data).
define('RPX_UPDATE_ALWAYS', 2);
// Update (overwriting the existing data), based on a weighted provider table.
define('RPX_UPDATE_MAYBE', 3);
// Update the data field as an additional value (for multi-value fields).
define('RPX_UPDATE_ADD', 4);

// The Engage web API library
require_once('rpx_core.webapi.inc');

/**
 * Implements hook_menu().
 */
function rpx_core_menu() {
  $items['rpx/token_handler'] = array(
    'title' => 'RPX Token Handler URL',
    'page callback' => 'rpx_token_handler',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'rpx_core.pages.inc',
  );
  $items['rpx/confirm/%/%/%'] = array(
    'title' => 'Confirm email',
    'page callback' => 'rpx_email_confirm',
    'page arguments' => array(2, 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'rpx_core.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Prefills the registration form with values acquired via Engage.
 */
function rpx_core_form_user_register_form_alter(&$form, &$form_state) {
  // Only alter if the user is signing in using Engage (the rpx session may
  // still be set if admin has signed in using Engage and is adding a user, so
  // check that this is not the case).
  if (!isset($_SESSION) || !isset($_SESSION['rpx']) || $_SESSION['rpx']['stat'] != 'ok' || user_access('administer users')) {
    return;
  }

  $profile = $_SESSION['rpx']['profile'];

  // Use the nickname returned by Engage.
  $form['account']['name']['#default_value'] = $profile['preferredUsername'];
  $mail = '';
  if (!empty($profile['verifiedEmail'])) {
    $mail = $profile['verifiedEmail'];
  }
  elseif (!empty($profile['email'])) {
    $mail = $profile['email'];
  }
  // Use the email returned by Engage, if any.
  $form['account']['mail']['#default_value'] = $mail;

  // If email verification is not required, hide the password field and
  // just fill with random password to avoid confusion.
  if (!empty($profile['verifiedEmail']) ||
      !variable_get('user_email_verification', TRUE) ||
      variable_get('rpx_bypass_email_verification', FALSE)) {

    $form['account']['pass']['#type'] = 'hidden';
    $form['account']['pass']['#value'] = user_password();
  }

  $form['engage_claimed_id'] = array(
    '#type' => 'value',
    '#default_value' => $profile['identifier'],
  );
  $form['id_display'] = array(
    '#type' => 'item',
    '#weight' => 10,
    '#title' => t('Your account ID'),
    '#description' => t('This @provider account will be linked to your site account after registration.', array('@provider' => $_SESSION['rpx_last_provider_info']['title'])),
    '#markup' => check_plain($profile['identifier']),
  );

  // replace the default user_register form submit handler with our own (because
  // we need to honor verifiedEmail and rpx_bypass_email_verification, save the
  // Engage user picture, etc.)
  $form['#submit'][array_search('user_register_submit', $form['#submit'])] = 'rpx_user_register_submit';

  $field_map = variable_get('rpx_profile_fields_map', array());
  if (empty($field_map)) {
    return;
  }

  // Use Engage data to pre-fill profile fields.
  if(module_exists('profile')) {
    // Build an array of Engage field ID's keyed by profile field name
    $map = array();
    foreach ($field_map as $mid => $field_mapping) {
      // Make sure it's a valid mapping.
      if (!isset($field_mapping['fid'])) {
        continue;
      }

      if($field_mapping['set'] == 'profile') {
        $map[$field_mapping['field']] = $field_mapping['fid'];
      }
    }
    // Search for profile fields and initialize them with Engage profile data.
    if(!empty($map)) {
      foreach ($form as $category_key => $category) {
        if (is_array($category)) {
          foreach ($category as $field_key => $field) {
            if (substr($field_key, 0, 8) == 'profile_' && isset($map[$field_key])) {
              $form[$category_key][$field_key]['#default_value'] = _rpx_data_map($_SESSION['rpx'], $map[$field_key]);
            }
          }
        }
      }
    }
  }

  // Use Engage data to pre-fill Profile2 fields.
  if(module_exists('profile2')) {
    // Build a map keyed by $bundle.$field (we cannot key by $field, as
    // fields in different bundles can have the same name).
    $map = array();
    foreach ($field_map as $mid => $field_mapping) {
      // Make sure it's a valid mapping.
      if (!isset($field_mapping['fid'])) {
        continue;
      }

      if($field_mapping['set'] == 'profile2') {
        $map[$field_mapping['bundle'] . $field_mapping['field']] = $field_mapping['fid'];
      }
    }
    if(!empty($map)) {
      foreach (field_info_instances('profile2') as $bundle => $fields) {
        foreach ($fields as $field => $array) {
          if (isset($map[$bundle.$field]) && $mapped_value = _rpx_data_map($_SESSION['rpx'], $map[$bundle.$field])) {
            $form['profile_' . $bundle][$field][LANGUAGE_NONE][0]['value']['#default_value'] = $mapped_value;
          }
        }
      }
    }
  }

  // Use Engage data to pre-fill User fields.
  $map = array();
  foreach ($field_map as $mid => $field_mapping) {
    // Make sure it's a valid mapping.
    if (!isset($field_mapping['fid'])) {
      continue;
    }

    if($field_mapping['set'] == 'user') {
      $map[$field_mapping['field']] = $field_mapping['fid'];
    }
  }
  if(!empty($map)) {
    foreach (field_info_instances('user') as $bundle => $fields) {
      foreach ($fields as $field => $array) {
        if (isset($map[$field]) && $mapped_value = _rpx_data_map($_SESSION['rpx'], $map[$field])) {
          $form[$field][LANGUAGE_NONE][0]['value']['#default_value'] = $mapped_value;
        }
      }
    }
  }
}

/**
 * Custom submit handler for the standard user_register form.
 */
function rpx_user_register_submit($form, &$form_state) {
  form_state_values_clean($form_state);

  $pass = user_password();

  $form_state['values']['pass'] = $pass;
  $form_state['values']['init'] = $form_state['values']['mail'];

  $account = $form['#user'];
  $category = $form['#user_category'];

  $account_unchanged = clone $account;

  entity_form_submit_build_entity('user', $account, $form, $form_state);

  $edit = array_intersect_key((array) $account, $form_state['values']);
  $account = user_save($account_unchanged, $edit, $category);

  // Add the Engage data to the account.
  $account = _rpx_populate_user_record($account, $_SESSION['rpx']);
  // Terminate if an error occurred during user_save().
  if (!$account) {
    drupal_set_message(t("Error saving user account."), 'error');
    $form_state['redirect'] = '';
    return;
  }
  // Add the 3rd party profile picture to the account.
  $account = _rpx_save_profile_picture($account);
  watchdog('rpx_core', 'New user: %name (%email).', array('%name' => $form_state['values']['name'], '%email' => $form_state['values']['mail']), WATCHDOG_NOTICE, l(t('edit'), 'user/' . $account->uid . '/edit'));

  $form_state['user'] = $account;
  $form_state['values']['uid'] = $account->uid;
  // Add plain text password into user account to generate mail tokens.
  $account->password = $pass;

  // If no email verification required, log the user in immediately.
  if ((!variable_get('user_email_verification', TRUE) ||
       variable_get('rpx_bypass_email_verification', FALSE) ||
       !empty($_SESSION['rpx']['profile']['verifiedEmail']) &&
       strtolower($account->mail) == strtolower($_SESSION['rpx']['profile']['verifiedEmail'])) &&
      $account->status) {

    _user_mail_notify('register_no_approval_required', $account);
    $form_state['uid'] = $account->uid;
    user_login_submit(array(), $form_state);
    drupal_set_message(t('Registration successful. You are now logged in.'));
  }
  elseif ($account->status) {
    // Require email confirmation
    drupal_mail('rpx_core', 'rpx_confirm_email', $account->mail, user_preferred_language($account), array('account' => $account));
    drupal_set_message(t('In order to confirm your email address, an email has been sent to you with confirmation instructions.'));
  }
  else {
    _user_mail_notify('register_pending_approval', $account);
    drupal_set_message(t('Thank you for applying for an account. Your account is currently pending approval by the site administrator.<br />In the meantime, a welcome message with further instructions has been sent to your e-mail address.'));
  }
  $form_state['redirect'] = '';
}

/**
 * Populates a given account's data with $profile from Engage
 */
function _rpx_populate_user_record(&$account, $payload) {
  $edit['data'] = array('rpx_data' => $payload);
  return user_save($account, $edit);
}

/**
 * Downloads user picture from the 3rd party and links it to the user account.
 *
 * Returns user account.
 */
function _rpx_save_profile_picture(&$account) {
  // Should we bother?
  if (!variable_get('rpx_import_profile_photo', 0) ||
      !variable_get('user_pictures', 0) ||
      !isset($account->data['rpx_data']['profile']['photo'])) {

    return $account;
  }

  $photo_url = $account->data['rpx_data']['profile']['photo'];

  // We need to have the file locally
  $tmp_photo = drupal_tempnam('temporary://', 'drupal_rpx-');
  $tmp_photo_realpath = drupal_realpath($tmp_photo);
  copy($photo_url, $tmp_photo_realpath);

  // We'll need a file object to work with the file
  $info = image_get_info($tmp_photo_realpath);
  $file = new stdClass();
  $file->uid      = $account->uid;
  $file->status   = 0; // mark the file as temporary
  $file->filename = basename($tmp_photo_realpath);
  $file->uri      = $tmp_photo;
  $file->filemime = $info['mime_type'];
  $file->filesize = $info['file_size'];

  // The file should be an image
  $errors = array();
  $errors += file_validate_is_image($file);
  $errors += file_validate_image_resolution($file, variable_get('user_picture_dimensions', '85x85'));
  $errors += file_validate_size($file, variable_get('user_picture_file_size', '30') * 1024);

  // Make sure file extension is a valid image
  if (!in_array(strtolower($info['extension']), array('jpg', 'png', 'gif'))) {
    $errors[] = ' invalid image file extension.';
  }

  if (count($errors)) {
    drupal_set_message(t('Profile Image Import:') . ' ' . $errors[0], 'warning');
    // Clean up (set fid to avoid error messages)
    $file->fid = 0; file_delete($file);
  }
  else {
    // We'll need a valid file id on the file object; file_save() will give us one
    $file = file_save($file);
    // Update user account (fid is not empty, status is temporary -- image
    // will be moved to proper directory and assigned to the user)
    $fields['picture'] = $file;
    $account = user_save($account, $fields);
  }

  return $account;
}

/**
 * Given an Engage field ID, return the Engage data it maps to.
 *
 * @see rpx_core_form_user_register_form_alter()
 * @see _rpx_import_user_data()
 */
function _rpx_data_map($data, $fid) {
  $path = db_query('SELECT path FROM {rpx_profile_field} WHERE fid = :fid', array('fid' => $fid))->fetchField();

  $result = '';
  // Use $path as a reference into the $data array.
  eval("isset(\$data{$path}) && \$result = \$data{$path};");

  return $result;
}

/**
 * Implements hook_mail().
 */
function rpx_core_mail($key, &$message, $params) {
  $language = $message['language'];
  $variables = array('user' => $params['account']);
  switch ($key) {
    case 'rpx_confirm_email':
      $message['subject'] = _rpx_mail_text($key .'_subject', $language, $variables);
      $message['body'][] = str_replace('user/reset', 'rpx/confirm', _rpx_mail_text($key .'_body', $language, $variables));
    break;
  }
}

/**
 * Returns a mail string for rpx_confirm_email_*.
 *
 * Used by rpx_core_mail() and the settings forms to retrieve mail strings.
 */
function _rpx_mail_text($key, $language = NULL, $variables = array(), $replace = TRUE) {
  $langcode = isset($language) ? $language->language : NULL;

  if ($admin_setting = variable_get('rpx_mail_' . $key, FALSE)) {
    // An admin setting overrides the default string.
    $text = $admin_setting;
  }
  else {
    // No override, return default string.
    switch ($key) {
      case 'rpx_confirm_email_subject':
        $text = t('Confirm your account at [site:name]', array(), array('langcode' => $langcode));
        break;
      case 'rpx_confirm_email_body':
        $text = t("[user:name],

Thank you for registering at [site:name].

To confirm your email address, click on this link or copy and paste it in your browser:

[user:one-time-login-url]

After confirming your email address, you will be able to log in to [site:name] using your new account.

--  [site:name] team", array(), array('langcode' => $langcode));
        break;
    }
  }

  if ($replace) {
    return token_replace($text, $variables, array('language' => $language, 'callback' => 'user_mail_tokens'));
  }

  return $text;
}

/**
 * Implements hook_user_insert().
 */
function rpx_core_user_insert(&$edit, $account, $category) {
  // Make sure user has registered via Engage.
  if (!isset($_SESSION['rpx'])) {
    return;
  }

  $profile = $_SESSION['rpx']['profile'];

  // Since we are inserting in two tables (authmap and rpx_linked_account),
  // use a transaction.
  $txn = db_transaction();
  try {
    user_set_authmaps($account, array('authname_rpx_core' => $profile['identifier']));
    if (module_exists('rpx_ui')) {
      // Get the new authmap ID and insert it in the rpx_linked_account table
      $aid = db_query('SELECT aid FROM {authmap} WHERE authname = :id', array('id' => $profile['identifier']))->fetchField();
      db_insert('rpx_linked_account')
        ->fields(array(
          'aid' => $aid,
          'provider_name' => $_SESSION['rpx_last_provider_info']['name'],
          'provider_title' => $_SESSION['rpx_last_provider_info']['title'],
        ))
        ->execute();
    }
  }
  catch (Exception $e) {
    $txn->rollback();
    watchdog_exception('rpx_core', $e);
  }
}

/**
 * Implements hook_menu_site_status_alter().
 */
function rpx_core_menu_site_status_alter(&$menu_site_status, $path) {
  // Allow access to rpx/token_handler if site is in offline mode.
  if ($menu_site_status == MENU_SITE_OFFLINE && user_is_anonymous() && $path == 'rpx/token_handler') {
    $menu_site_status = MENU_SITE_ONLINE;
  }
}

/**
 * Gets a list of Engage providers.
 *
 * @param boolean $entire_list
 *   If set, all available providers will be returned, including those that are
 *   not enabled.
 *
 * @return
 *   An array of provider titles keyed by provider machine name.
 */
function _rpx_providers($entire_list = FALSE) {
  $providers['aol'] = 'AOL';
  $providers['blogger'] = 'Blogger';
  $providers['facebook'] = 'Facebook';
  $providers['flickr'] = 'Flickr';
  $providers['google'] = 'Google';
  $providers['hyves'] = 'Hyves';
  $providers['linkedin'] = 'LinkedIn';
  $providers['live_id'] = 'Windows Live';
  $providers['livejournal'] = 'LiveJournal';
  $providers['myopenid'] = 'MyOpenID';
  $providers['myspace'] = 'MySpace';
  $providers['netlog'] = 'Netlog';
  $providers['openid'] = 'OpenID';
  $providers['paypal'] = 'PayPal';
  $providers['twitter'] = 'Twitter';
  $providers['verisign'] = 'VeriSign PIP';
  $providers['wordpress'] = 'Wordpress.com';
  $providers['yahoo'] = 'Yahoo!';

  if ($entire_list) {
    return $providers;
  }

  $config_providers = variable_get('rpx_enabled_providers', FALSE);
  if ($config_providers) {
    $active = array();
    foreach ($config_providers as $key) {
      $active[$key] = $providers[$key];
    }
  }
  else {
    $active = $providers;
  }

  return $active;
}

/**
 * Helper function: return sign-in provider info given an Engage ID. Now that we
 *   store provider info in its own table (rpx_linked_account), this function is
 *   only used when upgrading from 7.x-1.0-beta1 installations.
 *
 * @param string $id
 *   An Engage ID.
 *
 * @return
 *   An associative array with provider info (name and title).
 *
 * @todo
 *   This code assumes that the provider top-level domain names are all of
 *   the provider.tld type.
 */
function _rpx_get_identity_provider($id) {
  $entire_list = TRUE;
  $providers = _rpx_providers($entire_list);

  // Extract the FQDN from the id
  $provider = parse_url($id, PHP_URL_HOST);
  // Extract the provider name from the FQDN (assumes it is provider.tld).
  $parts = explode('.', $provider);
  array_pop($parts);
  $provider = array_pop($parts);

  $result = array(
    'name' => 'other',
    'title' => 'Other',
  );
  if (isset($providers[$provider])) {
    $result['name'] = $provider;
    $result['title'] = $providers[$provider];
  }
  return $result;
}

/**
 * Helper function: return machine name given a provider title returned by
 * Engage.
 *
 * @param string $title
 *   An Engage provider title.
 *
 * @return
 *   The provider's machine name if it is known; "other" otherwise.
 */
function _rpx_get_provider_machine_name($title) {
  $entire_list = TRUE;
  $providers = _rpx_providers($entire_list);
  $providers = array_flip($providers);

  return isset($providers[$title]) ? $providers[$title] : 'other';
}

/**
 * Returns the URL that will receive the Engage sign-in callback ("RPX token
 * handler URL")
 */
function _rpx_token_url($rpx_params = array()) {
  // Set destination so user will return to current page after login/registration
  $dest = drupal_get_destination();
  $dest = urldecode($dest['destination']);
  // If initiating Engage login/registration from login or registration page send
  // user to their account page
  if (strpos($dest, 'user/login') !== FALSE || strpos($dest, 'user/register') !== FALSE) {
    $dest = 'user';
  }
  $query[] = array('destination' => $dest);
  if (is_array($rpx_params)) {
    $query = array_merge($query, $rpx_params);
  }

  return url('rpx/token_handler', array('query' => $query, 'absolute' => TRUE));
}

/**
 * Helper function: log a missing field error.
 *
 * @param string $entity_type
 *   Name of entity the field belongs to (e.g. profile, profile2, user).
 * @param string $field_name
 *   Field name (e.g. profile_displayname).
 * @param string $user_name
 *   User name.
 */
function _rpx_report_missing_field($entity_type, $field_name, $user_name) {
  watchdog('rpx_core', 'Cannot map Janrain Engage data to the %entity field %field, as it does not seem to exist for user %user. Update your fields and/or the Janrain Engage field map.', array('%entity' => $entity_type, '%field' => $field_name, '%user' => $user_name), WATCHDOG_WARNING, l(t('Field Mapping'), 'admin/config/people/rpx/mapping'));
}

/**
 * Imports Engage user profile data into profile, profile2 and user entity
 * fields, based on the settings for each mapping.
 */
function _rpx_import_user_data() {
  global $user;
  $map = variable_get('rpx_profile_fields_map', array());
  $provider = $_SESSION['rpx_last_provider_info']['name'];

  foreach ($map as $mid => $mapping) {
    // Should we try to update the field at all?
    if (!isset($mapping['update']) || $mapping['update'] == RPX_UPDATE_NONE) {
      continue;
    }

    $new_data = _rpx_data_map($_SESSION['rpx'], $mapping['fid']);

    // Only update if provider returned data for the field.
    if($new_data === '') {
      continue;
    }

    // If data append is requested, make sure it's a multi-value field.
    if ($mapping['update'] == RPX_UPDATE_ADD) {
      $field_info = field_info_field($mapping['field']);
      if (!isset($field_info['cardinality']) || $field_info['cardinality'] == 1) {
        watchdog('rpx_core', 'Refusing to append new data to a single-value field %field_name.', array('%field_name' => $mapping['field']), WATCHDOG_WARNING);
        continue;
      }
    }

    // Check if whether we overwrite or not depends on the provider
    if ($mapping['update'] == RPX_UPDATE_MAYBE) {
      // Make sure this provider is in the mapping's provider list.
      if(($provider_weight = array_search($provider, $mapping['providers'])) === FALSE) {
        continue;
      }

      // Make sure this provider is not lower in the weight table than the
      // previous one.
      $prev_provider = db_select('rpx_mapping_provider')
        ->fields('rpx_mapping_provider', array('name'))
        ->condition('uid', $user->uid)
        ->condition('mid', $mid)
        ->execute()
        ->fetchAssoc();
      $prev_provider = $prev_provider ? $prev_provider['name'] : '';
      $prev_provider_weight = array_search($prev_provider, $mapping['providers']);
      if ($prev_provider_weight !== FALSE && $provider_weight > $prev_provider_weight) {
        continue;
      }
    }

    // Import into the profile fields.
    if(module_exists('profile') && $mapping['set'] == 'profile') {
      $profile = db_select('profile_field')
        ->fields('profile_field', array('fid'))
        ->condition('name', $mapping['field'])
        ->execute()
        ->fetchAssoc();

      // Check that field still exists.
      if (!$profile) {
        _rpx_report_missing_field('profile', $mapping['field'], $user->name);
        continue;
      }

      if ($mapping['update'] == RPX_UPDATE_EMPTY) {
        // Make sure the field is empty.
        $field = db_select('profile_value')
          ->fields('profile_value', array('value'))
          ->condition('fid', $profile['fid'])
          ->condition('uid', $user->uid)
          ->execute()
          ->fetchAssoc();
        if ($field && $field['value'] !== '') {
          continue;
        }
      }
      // Import the data.
      db_merge('profile_value')
        ->key(array(
          'fid' => $profile['fid'],
          'uid' => $user->uid,
          ))
        ->fields(array('value' => $new_data))
        ->execute();
    }
    else {
      // Check if we should import into the remaining (profile2 and user) entity
      // types.
      if(module_exists('profile2') && $mapping['set'] == 'profile2') {
        $entity_type = 'profile2';
        $entity = profile2_load_by_user($user->uid, $mapping['bundle']);
      }
      else if ($mapping['set'] == 'user') {
        $entity_type = 'user';
        $account = user_load($user->uid);
        $entity = new stdClass();
        $entity->uid = $user->uid;
        if(isset($account->{$mapping['field']})) {
          $entity->{$mapping['field']} = $account->{$mapping['field']};
        }
      }

      // Check that field still exists.
      if (!isset($entity->{$mapping['field']})) {
        _rpx_report_missing_field($entity_type, $mapping['field'], $user->name);
        continue;
      }

      $values = &$entity->{$mapping['field']}[LANGUAGE_NONE];

      if ($mapping['update'] == RPX_UPDATE_EMPTY) {
        // Make sure the field is empty.
        if(isset($values[0]['value'])) {
          continue;
        }
      }

      //
      // Import the data (profile2 and user entity types).
      //
      if($mapping['update'] == RPX_UPDATE_ADD) {
        // If we are appending to a multi-value field, make sure it can accept
        // another value.
        if ($field_info['cardinality'] != -1 && count($values) >= $field_info['cardinality']) {
          watchdog('rpx_core', 'Refusing to append new data: multi-value field %field_name can\'t accept another value.', array('%field_name' => $mapping['field']), WATCHDOG_WARNING);
          continue;
        }
        elseif ($values) {
          // Make sure $new_data value isn't already there.
          $exists = FALSE;
          foreach ($values as $value) {
            if (!strcmp($value['value'], $new_data)) {
              $exists = TRUE;
              break;
            }
          }
          if ($exists) {
            continue;
          }
          else {
            $slot = count($values);
          }
        }
        else {
          // Field has no values.
          $slot = 0;
        }
      }
      else {
        $slot = 0;
      }

      $values[$slot]['value'] = $new_data;
      field_attach_update($entity_type, $entity);
    }

    if($mapping['update'] != RPX_UPDATE_ADD) {
      // Record the provider's name as the last provider used in the mapping.
      db_merge('rpx_mapping_provider')
        ->key(array(
          'uid' => $user->uid,
          'mid' => $mid,
          ))
        ->fields(array('name' => $provider))
        ->execute();
    }
  }
}
